# Синтаксический анализатор. Документация

## Про запуск
Примеры кодов на ParsoTanger и их деревьев разбора есть в директории `examples/`, так же есть примеры разборов подвыражений в тестах `tests/`.

Запустить программу можно так:
Запустить src/Main.java с двумя аргументами -- входным и выходным файлои. Во входном должно быть программа, для котороq требуется построить дерево разбора, в выходной файл будет напечатано дерево разбора.
Например, можно запустить с параметрами `in.txt` и `out.txt`.

## Про язык
Есть два типа данных, целочисленный (`int`) и строки (`str`).


Всю программу можно разбить на объявления функций и наборы инструкций в глобальной памяти.

+ Инструции в глобальной памяти:
  - Заведение новой глобальной переменной с присваиванием (`:=`), например
    `int x := 0;` В левой части тип и название переменной. Переменные должны состоять только из букв и цифр, при этом начинаться должны с буквы. В правой части присваивания должно быть какое-то выражение (или функция), возвращающая `int`. Анализатор будет делать проверку типов, если будет несоответствие, то будет выведена ошибка. Примеры:
    
    1. вход: `int x := 30;` выход:
     ```
     [PROGRAM]
        |
        +---->[DEF int x]--->[INT,30]
     ```
    1. вход: `int x := "aaa";`
      выход:
      ```
        [PROGRAM]
            |
            +---->[ERR Expression expected to be IntExpr but was StringExpr]
      ```
  - Переприсваивание в уже существующую глоальную переменную. Например, `x := x + 1;`. Тип в таком случае не указывается. Менять тип переменной нельзя.
  - Условные операторы. Бывает двух типов:
    1. `if [выражение] then [набор инструкций] fi`
    1. `if [выражение] then [набор инструкций] else [набор инструкций] fi`
    Условные операторы могут быть вложенными (`example3.in`).
    Появляется понятие области видимости: в непересекающихя областях видимости можно объявлять переменные с одинаковым именем, но разного типа.
  - внутри функций доступна инструкция return, через неё можно возвращать выражения, вызывать другие функции Например,
    ```
        return x;
        return f();
        return 1 + 2 * t; 
    ```
  - вызов функции: имя функции и перечисление аргументов в скобках. Аргументы -- выражения надпеременными, константами, а так же результатами работы других функций. Например,
    ```
        f(a, "www" == s, g(1));
        h();
    ```

Анализатор арифметических выражений умеет получать на вход строку, состоящую из чисел, строк (обособленных кавычками `"`), переменных, вызовов функций, разделенными бинарными арифметическими операторами (`+`, `-`, `/`, `%`, `*`), а также операторами сравнения, а также скобками `(` и `)`.

Синтаксический анализатор работает так:
1) Сначала делает базовые проверки на корректность выражения (чётное число кавычек, скобки образуют правильную скобочную последовательность, никакие переменные не начинаются на цифры, не используются никакие знаки кроме латиницы и цифр (не считая арифметических операторов))
2) Затем перечитывается строка и по ней строится дерево разбора. Используется что-то вроде LR-анализатора: парсер по очереди читает по объекту (скобке/переменной/числу/бинарному оператору) из строки, и хранит их в стеке. Как только он читает закрывающуюся скобку, он останавливается, чтобы упростить выражение от последней открывающейся скобки до текущего места, и упрощает это выражение (до строки или числа), и затем продолжает читать. И в конце, когда он дочитал строку, он тоже упрощает строку, и выясняет, что задает всё выражение (число, строку, или что-то ошибочное).\
В выражении допускаются любые бинарные операции между числами, умножение чисел на строки, сложение строк и сравнение строк операторами == и !=. Если имеют место другие случаи (например, сложение строки с числом `"aba" + 2`), то результат выражения -- ошибка.\
Знаки с самым большим приоритетом: `*,/,%`.
Приоритет чуть поменьше у `+,-`. Ещё меньше приоритет у знаков `>, <, >=, <=`. Самый маленький приоритет у равенства и неравенства.

Примеры корректных выражений:

```
((1))
1+2 < 3
( (1) ==   ((2))) < (3)  
1+2+3+4+("a"!="b"*4)!=7 
((1+2+3+(2<=4)==7)*2<2+1)*"aba"=="aba"+"caba"
"aba"*(3+2)
(f() == f()) + 3 // если f() возврщает str или int
```
Примеры некорректных выражений:
```
((1)
1++2
"5"/1
"aba"*3+2
```

Ещё можно объявлять функции в глобальной памяти. Синтаксис такой: сначала ключевое слово `def`, потом возвращаемый тип (void/int/str), название функции (не должно совпадать с уже объявленными функциями.глобальными переменными), а затем перечисление переменных в круглых скобках (например, `(int x, str y, int u)`) Имена переменных не должны совпадать с глобальными. Затем тело функции и ключевое слово `enddef`. Например,
```
def int gcd(int a, int b)
if
    a == 0
then
    return b;
else
    return gcd(b % a, a);
fi
enddef
```

## Про асимптотику
Алгоритм преобразования *выражения* в дерево использует $O(n)$ памяти и времени, где $n$ -- длина выражения. Асимптотически быстрее никак, потому что чтение строки это уже $O(n)$ времени, и хранение дерева это уже $O(n)$ памяти.

Вывод в текстовом виде этого дерева потенциально занимает $O(n^2)$ времени и памяти (в случае `1+1+...+1` дерево представляет что-то похожее на прямоугольный треугольник с катетами длины $O(n)$). Для этого есть соответствующий стресс-тест.

Парсинг большого количества вложенных условных операторов тоже работает линейно от их количества: потому что в реализации читаются они один раз слева направо и поддерживается стек, в котором хранится информация о ещё недочитанных условных операторах.

Аналогично можно сделать и для вызовов функций, чтобы выражение `f(f(f(..f(1))))` парсилось за линию от длины. У меня пока что написано за квадрат. Это пока что узкое место парсера и его можно будет улучшить.

Обработка частично некорректного кода есть (например в `examples/example1`). При ошибках в выражениях выводится название ошибки, либо даже дерева разбора (в нем появляются вершины, помеченные ERR -- соответствующие им подстроки инвалидны). При других ошибках низкого уровня (в инструкциях присваивания, return) тоже есть вывод ошибок.

При ошибках высокого уровня (например, не завершено объявление функции), до места ошибки будет выведено дерево разбора, а дальше ничего.

## Что не работает, или работает плохо, но можно сделать
1. В ParsoTangue нельзя объявлять функции внутри функций.
1. Поработать над унификацией вывода ошибок.
1. Периодически что-то может стрелять -- тестов много, но они покрывают не всё.
1. В нескольких местах есть похожий код (например, при парсинге, надо часто надо пропускать всё, обособленное кавычками). Нужно подумать над обобщением методов для таких вещей.
1. Можно добавить ускорение парсинга вложенных вызовов `f(f...f(1))` с $O(n^2)$ до $O(n)$.
