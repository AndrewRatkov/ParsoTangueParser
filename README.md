## Синтаксический анализатор

Сейчас поддерживаются только арифметические выражения.

Анализатор умеет получать на вход строку, состоящую из чисел, строк (обособленных кавычками `"`), бинарных арифметических операторов (`+`, `-`, `/`, `%`, `*`), а также операторов сравнения, а также скобок `(` и `)`.

Синтаксический анализатор работает так:
1) Сначала делает базовые проверки на корректность выражения (чётное число кавычек, скобки образуют правильную скобочную последовательность, никакие переменные не начинаются на цифры, не используются никакие знаки кроме латиницы и цифр (не считая арифметических операторов))
2) Затем перечитывается строка и по ней строится дерево разбора. Используется что-то вроде LR-анализатора: парсер по очереди читает по объекту (скобке/переменной/числу/бинарному оператору) из строки, и хранит их в стеке. Как только он читает закрывающуюся скобку, он останавливается, чтобы упростить выражение от последней открывающейся скобки до текущего места, и упрощает это выражение (до строки или числа), и затем продолжает читать. И в конце, когда он дочитал строку, он тоже упрощает строку, и выясняет, что задает всё выражение (число, строку, или что-то ошибочное).\
В выражении допускаются любые бинарные операции между числами, умножение чисел на строки, сложение строк и сравнение строк операторами == и !=. Если имеют место другие случаи (например, сложение строки с числом `"aba" + 2`), то результат выражения -- ошибка.\
Знаки с самым большим приоритетом: `*,/,%`.
Приоритет чуть поменьше у `+,-`. Ещё меньше приоритет у знаков `>, <, >=, <=`. Самый маленький приоритет у равенства и неравенства.

Примеры корректных выражений:

```
((1))
1+2 < 3
( (1) ==   ((2))) < (3)  
1+2+3+4+("a"!="b"*4)!=7 
((1+2+3+(2<=4)==7)*2<2+1)*"aba"=="aba"+"caba"
"aba"*(3+2)
```
Примеры некорректных выражений:
```
((1)
1++2
"5"/1
"aba"*3+2
```

## Как запустить программу
Запустить src/Main.java с двумя аргументами -- входным и выходным файлои. Во входном должно быть выражение, для которого требуется построить дерево разбора, в выходной файл будет напечатано дерево разбора.

Например, что-то такое (см `in.txt` и `out.txt`).

```
[INT,!=]------->[INT,+ ]------->[INT,+ ]------->[INT,+ ]------->[INT,+ ]------->[INT,1]
    |               |               |               |               |
    |               |               |               |               +---------->[INT,2]
    |               |               |               |
    |               |               |               +---------->[INT,3]
    |               |               |
    |               |               +---------->[INT,4]
    |               |
    |               +---------->[INT,!=]------->[STR,"a"]
    |                               |
    |                               +---------->[STR,* ]------->[STR,"b"]
    |                                               |
    |                                               +---------->[INT,4]
    |
    +---------->[INT,7]

```

## Про асимптотику
Алгоритм преобразования выражения в дерево использует $O(n)$ памяти и времени, где $n$ -- длина выражения. Асимптотически быстрее никак, потому что чтение строки это уже $O(n)$ времени, и хранение дерева это уже $O(n)$ памяти.

Вывод в текстовом виде этого дерева потенциально занимает $O(n^2)$ времени и памяти (в случае `1+1+...+1` дерево представляет что-то похожее на прямоугольный треугольник с катетами длины $O(n)$).